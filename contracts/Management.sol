// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

/** @author Omnes Blockchain team (@EWCunha, @Afonsodalvi and @G-Deps)
    @title Management contract for W3DFUNDING project */

/// -----------------------------------------------------------------------
/// Imports
/// -----------------------------------------------------------------------


///@dev implement this collection: https://github.com/defientco/ERC721H/blob/main/src/ERC721ACH.sol

import {IManagement,IERC20Burnable} from "./interfaces/IManagement.sol";
import {IERC721Acompany} from "./interfaces/IERC721Acompany.sol";

///@dev beacon proxy smart contract
//import {BeaconProxy} from "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol";

///@dev UUPS smart contract
//import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";


///@dev beacon proxy smart contract
import {BeaconProxy} from "./@openzeppelin/proxy/beacon/BeaconProxy.sol";

///@dev UUPS smart contract
import {UUPSUpgradeable} from "./@openzeppelin/proxy/utils/UUPSUpgradeable.sol";

///@dev security settings.
import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {ReentrancyGuardUpgradeable} from "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";

contract Management is 
IManagement,
Initializable,
UUPSUpgradeable,
ReentrancyGuardUpgradeable,
PausableUpgradeable
{

/// -----------------------------------------------------------------------
    /// Storage variables
    /// -----------------------------------------------------------------------

    // Beacon admins addresses
    address internal s_beaconAdminArt;
    address internal s_beaconAdminFund;
    address internal s_beaconAdminCompany;
    address internal s_beaconAdminStaking;
    //ICRPReward internal s_proxyReward;

    // Multisig address
    address internal s_multiSig;

    ///@dev mapping from user address to Creator struct. See {struct IManagement.Creator}
    mapping(address /* user */ => Creator /* info */) internal s_Company;

    ///@dev mapping that specifies if address is a manager (true) or not (false)
    mapping(address /* account */ => bool /* isManager */) internal s_managers;

    ///@dev mapping for the token contract
    mapping(Coin /* coin */ => IERC20Burnable /* contractInstance */)
        internal s_tokenContract;

    ///@dev mapping that checks if creator/artist is corrupted
    mapping(address /* creator */ => bool /* isCorrupted */)
        internal s_isCorrupted;

    ///@dev mapping of collection addresses generated by Company
    mapping(address /* collection */ => bool /* isFromCompany */)
        internal s_collections;

    ///@dev mapping of staking collection addresses generated by Company
    mapping(address /* stakingContractAddress */ => bool /* isFromCompany */)
        internal s_stakingCollections;

    //constants
    uint256 internal constant FEE = 200; // over 10000
    uint256 internal constant MAX_CREATOR_ROYALTY = 600; // over 10000

    /// -----------------------------------------------------------------------
    /// Permissions and Restrictions (private functions as modifiers)
    /// -----------------------------------------------------------------------

    /** @dev only allowed creator addresses can call function.
        @param creator: address to be checked */
    function _onlyCompany(address creator) internal view virtual {
        if (!s_Company[creator].isAllowed) {
            revert Management__NotAllowed();
        }
    }

    ///@dev only allowed CompanyPRO manager addresses can call function.
    function _onlyManagers() internal view virtual {
        if (!s_managers[msg.sender]) {
            revert Management__NotAllowed();
        }
    }

    ///@dev only allowed CompanyPRO manager addresses can call function.
    function _onlyAuthorized() internal view virtual {
        if (!s_managers[msg.sender] && !s_Company[msg.sender].isAllowed) {
            revert Management__NotAllowed();
        }
    }

    /** @dev validates name and symbol parameters before creating NFT collection smart contract. 
        @param name: name of the NFT collection
        @param symbol: symbol of the NFT collection */
    function _validateCollectionParams(
        string memory name,
        string memory symbol
    ) internal pure virtual {
        if (!(bytes(name).length > 0)) {
            revert Management__InvalidName();
        }
        if (!(bytes(symbol).length > 0)) {
            revert Management__InvalidSymbol();
        }
    }

    /** @dev checks if given address is not the zero address.
        @param add: given address */
    function _validateAddress(address add) internal pure virtual {
        if (add == address(0)) {
            revert Management__InvalidAddress();
        }
    }

    /** @dev checks if caller is corrupted. 
        @param creator: address to be checked */
    function _notCorrupted(address creator) internal view virtual {
        if (s_isCorrupted[creator]) {
            revert Management__CreatorCorrupted();
        }
    }

    ///@dev internal function for whenNotPaused modifier
    function _whenNotPaused() internal view whenNotPaused {}

    ///@dev internal function for nonReentrant modifier
    function _nonReentrant() internal nonReentrant {}

    /// -----------------------------------------------------------------------
    /// Constructor (specific for upgradeable contracts)
    /// -----------------------------------------------------------------------

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /// -----------------------------------------------------------------------
    /// Initializer
    /// -----------------------------------------------------------------------

    /// @dev initializer modifier added.
    /// @inheritdoc IManagement
    function initialize(
        //address beaconAdminArt,
        address beaconAdminFund,
        address beaconAdminCompany,
        address erc20USD,
        address multiSig
    ) external virtual override(IManagement) initializer {
        __ReentrancyGuard_init();
        __Pausable_init();

        //s_beaconAdminArt = beaconAdminArt;
        s_beaconAdminFund = beaconAdminFund;
        s_beaconAdminCompany = beaconAdminCompany;
        s_tokenContract[Coin.USD_TOKEN] = IERC20Burnable(erc20USD);
        s_multiSig = multiSig;
        s_managers[tx.origin] = true;
        // managers[address(this)] = true;
    }

    /// -----------------------------------------------------------------------
    /// New collection functions
    /// -----------------------------------------------------------------------

    
    /** @dev function to be used by the creator. Same rules for the newCrowdfund public function (below) */
    /// @inheritdoc IManagement
    function newCrowdfund(
        string memory name,
        string memory symbol,
        string memory baseURI,
        /*uint256 royalty,*/
        CrowdFundParams memory cfParams
    ) external virtual override(IManagement) {
        newCrowdfund(name, symbol, baseURI, msg.sender, cfParams);
    }

    /** @dev only allowed Company. name and symbol must not be empty.
    s_beaconAdminFund must not be zero address. */
    /// @inheritdoc IManagement
    function newCrowdfund(
        string memory name,
        string memory symbol,
        string memory baseURI,
        /*uint256 royalty,*/
        address owner,
        CrowdFundParams memory cfParams
    ) public virtual override(IManagement) {
        _nonReentrant();
        _whenNotPaused();
        _onlyAuthorized();
        _validateCollectionParams(name, symbol);
        _validateAddress(s_beaconAdminFund);
        _onlyCompany(owner);
        _notCorrupted(owner);

        if (
            cfParams.amountLowQuota +
                cfParams.amountRegQuota +
                cfParams.amountHighQuota ==
            0
        ) {
            revert Management__FundMaxSupplyIs0();
        }

        // if (royalty > MAX_CREATOR_ROYALTY) {
        //     royalty = MAX_CREATOR_ROYALTY;
        // }

        bytes memory ERC721AcompanyInitialize = abi.encodeWithSignature(
            "initialize(string,string,address,uint256,uint256,uint256,uint256,string)",
            name,
            symbol,
            owner,
            cfParams.amountLowQuota +
                cfParams.amountRegQuota +
                cfParams.amountHighQuota,
            type(uint256).max,
            type(uint256).max,
            type(uint256).max,
            baseURI
            //royalty
        );

        BeaconProxy newArtCollectionProxy = new BeaconProxy(
            s_beaconAdminArt,
            ERC721AcompanyInitialize
        );

        bytes memory ERC721FundInitialize = abi.encodeWithSignature(
            "initialize(uint256[3],uint256[3],uint256[3],uint256,uint256,uint256,address,uint256,uint256,uint256,address)",
            cfParams.valuesLowQuota,
            cfParams.valuesRegQuota,
            cfParams.valuesHighQuota,
            cfParams.amountLowQuota,
            cfParams.amountRegQuota,
            cfParams.amountHighQuota,
            cfParams.donationReceiver,
            cfParams.donationFee,
            cfParams.minSoldRate,
            cfParams.crowdfundDuration,
            address(newArtCollectionProxy)
        );

        BeaconProxy newFundCollectionProxy = new BeaconProxy(
            s_beaconAdminFund,
            ERC721FundInitialize
        );

        ///@dev I will insert the definitions of the ERC721Acompany
        IERC721Acompany(address(newArtCollectionProxy)).setCrowdfund(
            address(newFundCollectionProxy)
        );

        s_collections[address(newArtCollectionProxy)] = true;

        emit Crowdfund(
            address(newFundCollectionProxy),
            address(newArtCollectionProxy),
            owner,
            msg.sender
        );
    }

    /** @dev only allowed managers. name and symbol must not be empty.
    s_beaconAdminCompany must not be zero address. */
    /// @inheritdoc IManagement
    // function newCompanyCollection(
    //     string memory name,
    //     string memory symbol,
    //     uint256 maxSupply,
    //     uint256 price,
    //     uint256 priceInUSDC,
    //     uint256 priceInCompanyCoin,
    //     string memory baseURI
    // ) external virtual override(IManagement) {
    //     _nonReentrant();
    //     _whenNotPaused();
    //     _onlyManagers();
    //     _validateCollectionParams(name, symbol);
    //     _validateAddress(s_beaconAdminCompany);

    //     bytes memory ERC721initialize = abi.encodeWithSignature(
    //         "initialize(string,string,address,uint256,uint256,uint256,uint256,string,uint256)",
    //         name,
    //         symbol,
    //         msg.sender,
    //         maxSupply,
    //         price,
    //         priceInUSDC,
    //         priceInCompanyCoin,
    //         baseURI,
    //         0
    //     );

    //     BeaconProxy newCollectionProxy = new BeaconProxy(
    //         s_beaconAdminCompany,
    //         ERC721initialize
    //     );

    //     s_collections[address(newCollectionProxy)] = true;

    //     emit CompanyCollection(address(newCollectionProxy), msg.sender);
    // }

    /** @dev function to be used by the creator. Same rules for the newCRPStaking public function (below) */
    /// @inheritdoc IManagement
    // function newCRPStaking(
    //     address stakingToken,
    //     uint256 timeUnit,
    //     uint256[3] calldata rewardsPerUnitTime
    // ) external virtual override(IManagement) {
    //     newCRPStaking(stakingToken, timeUnit, rewardsPerUnitTime, msg.sender);
    // }

    /** @dev only allowed Company. s_beaconAdminStaking must not be zero address. */
    /// @inheritdoc IManagement
    // function newCRPStaking(
    //     address stakingToken,
    //     uint256 timeUnit,
    //     uint256[3] calldata rewardsPerUnitTime,
    //     address owner
    // ) public virtual override(IManagement) {
    //     _nonReentrant();
    //     _whenNotPaused();
    //     _onlyAuthorized();
    //     _validateAddress(s_beaconAdminStaking);
    //     _onlyCompany(owner);
    //     _notCorrupted(owner);

    //     if (!s_collections[stakingToken]) {
    //         revert Management__InvalidCollection();
    //     }
    //     ///@dev I will insert the definitions of the ERC721AH
    //     // if (IERC721ArtHandle(stakingToken).owner() != owner) {
    //     //     revert Management__NotCollectionCreator();
    //     // }

    //     bytes memory CRPStakingInitialize = abi.encodeWithSignature(
    //         "initialize(address,uint256,uint256[3])",
    //         stakingToken,
    //         timeUnit,
    //         rewardsPerUnitTime
    //     );

    //     BeaconProxy newStakingProxy = new BeaconProxy(
    //         s_beaconAdminStaking,
    //         CRPStakingInitialize
    //     );

    //     s_collections[address(newStakingProxy)] = true;
    //     s_stakingCollections[address(newStakingProxy)] = true;

    //     emit CRPStaking(address(newStakingProxy), owner, msg.sender);
    // }

    /// -----------------------------------------------------------------------
    /// Setter functions
    /// -----------------------------------------------------------------------

    

    /** @dev only managers allowed to call this function. manager must
    not be zero address. */
    /// @inheritdoc IManagement
    function setManager(
        address manager,
        bool allowed
    ) external virtual override(IManagement) {
        _nonReentrant();
        _whenNotPaused();
        _onlyManagers();
        _validateAddress(manager);

        s_managers[manager] = allowed;

        emit ManagerSet(manager, allowed, msg.sender);
    }

    /** @dev only managers allowed to call this function. beacon must
    not be zero address. */
    /// @inheritdoc IManagement
    function setBeaconAdminArt(
        address beacon
    ) external virtual override(IManagement) {
        _nonReentrant();
        _whenNotPaused();
        _onlyManagers();
        _validateAddress(beacon);

        s_beaconAdminArt = beacon;

        emit NewBeaconAdminArt(beacon, msg.sender);
    }

    /** @dev only managers allowed to call this function. beacon must
    not be zero address. */
    /// @inheritdoc IManagement
    function setBeaconAdminFund(
        address beacon
    ) external virtual override(IManagement) {
        _nonReentrant();
        _whenNotPaused();
        _onlyManagers();
        _validateAddress(beacon);

        s_beaconAdminFund = beacon;

        emit NewBeaconAdminFund(beacon, msg.sender);
    }

    /** @dev only managers allowed to call this function. beacon must
    not be zero address. */
    /// @inheritdoc IManagement
    function setBeaconAdminCompany(
        address beacon
    ) external virtual override(IManagement) {
        _nonReentrant();
        _whenNotPaused();
        _onlyManagers();
        _validateAddress(beacon);

        s_beaconAdminCompany = beacon;

        emit NewBeaconAdminCompany(beacon, msg.sender);
    }

    /** @dev only managers allowed to call this function. multisig must
    not be zero address. */
    /// @inheritdoc IManagement
    function setMultiSig(
        address multisig
    ) external virtual override(IManagement) {
        _nonReentrant();
        _whenNotPaused();
        _onlyManagers();
        _validateAddress(multisig);

        s_multiSig = multisig;

        emit NewMultiSig(multisig, msg.sender);
    }

    /** @dev only managers allowed to call this function */
    /// @inheritdoc IManagement
    function setTokenContract(
        Coin coin,
        address token
    ) external virtual override(IManagement) {
        _nonReentrant();
        _whenNotPaused();
        _onlyManagers();
        _validateAddress(token);
        if (coin == Coin.ETH_COIN) {
            revert Management__CannotSetAddressForETH();
        }

        /**@dev Mumbai address = 0xA02f6adc7926efeBBd59Fd43A84f4E0c0c91e832
            Polygon mainnet address = 0xc2132D05D31c914a87C6611C10748AEb04B58e8F
            Goerli address = 0x509Ee0d083DdF8AC028f2a56731412edD63223B9
            Ethereum mainnet address = 0xdAC17F958D2ee523a2206206994597C13D831ec7 */
        s_tokenContract[coin] = IERC20Burnable(token);

        emit TokenContractSet(msg.sender, token, coin);
    }

    /** @dev only managers allowed to call this function */
    /// @inheritdoc IManagement
    function setCorrupted(
        address creator,
        bool corrupted
    ) external virtual override(IManagement) {
        _nonReentrant();
        _whenNotPaused();
        _onlyManagers();
        _validateAddress(creator);
        if (!s_Company[creator].isAllowed) {
            revert Management__AddressNotCreator();
        }

        s_isCorrupted[creator] = corrupted;

        emit CorruptedAddressSet(msg.sender, creator, corrupted);
    }

    /** @dev only managers allowed to call this function. beacon must
    not be zero address. */
    /// @inheritdoc IManagement
    function setBeaconAdminStaking(
        address beacon
    ) external virtual override(IManagement) {
        _nonReentrant();
        _whenNotPaused();
        _onlyManagers();
        _validateAddress(beacon);

        s_beaconAdminStaking = beacon;

        emit NewBeaconAdminStaking(beacon, msg.sender);
    }

    /** @dev only managers allowed to call this function. proxy must
    not be zero address. */
    /// @inheritdoc IManagement
    // function setProxyReward(
    //     address proxy
    // ) external virtual override(IManagement) {
    //     _nonReentrant();
    //     _whenNotPaused();
    //     _onlyManagers();
    //     _validateAddress(proxy);

        //s_proxyReward = ICRPReward(proxy);

    //     emit NewProxyReward(proxy, msg.sender);
    // }

    /** @dev whenNotPaused and nonReentrant third parties modifiers added. Only management contract
    is allowed to call this function. */
    /// @inheritdoc IManagement
    // function setCollections(
    //     address collection,
    //     bool set
    // ) external virtual override(IManagement) {
    //     _nonReentrant();
    //     _whenNotPaused();
    //     _onlyManagers();
    //     if (
    //         collection.code.length == 0 ||
    //         !s_Company[IERC721ArtHandle(collection).owner()].isAllowed
    //     ) {
    //         revert Management__InvalidAddress();
    //     }

    //     s_collections[collection] = set;

    //     emit CollectionSet(collection, set);
    // }

    // --- Pause and Unpause functions ---

    /** @dev only managers allowed to call this function. Uses _pause internal function from PausableUpgradeable. */
    /// @inheritdoc IManagement
    function pause() external virtual override(IManagement) {
        _nonReentrant();
        _onlyManagers();

        _pause();
    }

    /** @dev only managers allowed to call this function. Uses _pause internal function from PausableUpgradeable. */
    /// @inheritdoc IManagement
    function unpause() external virtual override(IManagement) {
        _nonReentrant();
        _onlyManagers();

        _unpause();
    }

    /// -----------------------------------------------------------------------
    /// Getter functions
    /// -----------------------------------------------------------------------

    /// @inheritdoc IManagement
    function getBeaconAdminArt()
        external
        view
        virtual
        override(IManagement)
        returns (address)
    {
        return s_beaconAdminArt;
    }

    /// @inheritdoc IManagement
    function getBeaconAdminFund()
        external
        view
        virtual
        override(IManagement)
        returns (address)
    {
        return s_beaconAdminFund;
    }

    /// @inheritdoc IManagement
    function getBeaconAdminCompany()
        external
        view
        virtual
        override(IManagement)
        returns (address)
    {
        return s_beaconAdminCompany;
    }

    /// @inheritdoc IManagement
    function getBeaconAdminStaking()
        external
        view
        virtual
        override(IManagement)
        returns (address)
    {
        return s_beaconAdminStaking;
    }

    /// @inheritdoc IManagement
    // function getProxyReward()
    //     external
    //     view
    //     virtual
    //     override(IManagement)
    //     returns (ICRPReward)
    // {
    //     return s_proxyReward;
    // }

    /// @inheritdoc IManagement
    function getMultiSig()
        external
        view
        virtual
        override(IManagement)
        returns (address)
    {
        return s_multiSig;
    }

    /// @inheritdoc IManagement
    function getFee()
        external
        pure
        virtual
        override(IManagement)
        returns (uint256)
    {
        return FEE;
    }

    /// @inheritdoc IManagement
    function getManagers(
        address caller
    ) external view virtual override(IManagement) returns (bool) {
        return s_managers[caller];
    }

    /// @inheritdoc IManagement
    function getTokenContract(
        Coin coin
    ) external view virtual override(IManagement) returns (IERC20Burnable) {
        return s_tokenContract[coin];
    }

    /// @inheritdoc IManagement
    function getIsCorrupted(
        address creator
    ) external view virtual override(IManagement) returns (bool) {
        return s_isCorrupted[creator];
    }

    /// @inheritdoc IManagement
    function getCollections(
        address collection
    ) external view virtual override(IManagement) returns (bool) {
        return s_collections[collection];
    }

    /// @inheritdoc IManagement
    function getStakingCollections(
        address collection
    ) external view virtual override(IManagement) returns (bool) {
        return s_stakingCollections[collection];
    }

    /// @inheritdoc IManagement
    function getImplementation()
        external
        view
        virtual
        override(IManagement)
        returns (address)
    {
        return _getImplementation();
    }

    /// @inheritdoc IManagement
    function getCreator(
        address creator
    ) external view virtual override(IManagement) returns (Creator memory) {
        return s_Company[creator];
    }

    /// -----------------------------------------------------------------------
    /// Overriden functions
    /// -----------------------------------------------------------------------

    /** @dev only managers are allowed to call this function. */
    /// @inheritdoc UUPSUpgradeable
    function _authorizeUpgrade(
        address
    ) internal view virtual override(UUPSUpgradeable) {
        _onlyManagers();
    }

    /// -----------------------------------------------------------------------
    /// Storage space for upgrades
    /// -----------------------------------------------------------------------

    uint256[44] private __gap;
}